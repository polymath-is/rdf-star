<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>RDF* and SPARQL*</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
  <script class="remove">
   // All config options at https://respec.org/docs/
   var respecConfig = {
      specStatus: "CG-DRAFT",
      editors: [
        {
          "name": "Olaf Hartig",
          "url": "https://olafhartig.de/",
          "company": "Linköping University",
          "orcid": "0000-0002-1741-2090",
          "companyURL": "https://liu.se/",
        },{
          "name":       "Pierre-Antoine Champin",
          "url":        "http://champin.net/",
          "company":    "ERCIM",
          "companyURL": "https://www.ercim.eu/",
          "w3cid":      42931,
          "orcid": "0000-0001-7046-4474",
        },
      ],
      authors: [
      {
          "name": "Dörthe Arndt",
          "company": "Ghent University",
        },
        {
          "name": "Bryan Thompson",
          "company": "Amazon",
        },
        {
          "name": "Jeen Broekstra",
          "company": "metaphacts",
        },
      ],
      github: "w3c/rdf-star",
      shortName: "rdf-star",
      group: "rdf-dev",
      xref: ["RDF11-CONCEPTS", "SPARQL11-QUERY", "RDF11-MT"],
      maxTocLevel: 2,
    };
  </script>
  <style>
    /* copied from TR/turtle, and adapted for SPARQL rules */
    .grammar td { font-family: monospace; vertical-align: top; }
    .grammar-literal, .token { color: gray;}
    .grammar_comment { color: #A52A2A; font-style: italic; }

    /* better looking embedded examples */
    .example .example {
      border-left-width: .15em;
    }
  </style>
  <script>
    /* copied from JSON-LD specs */
    function updateExample(doc, content) {
      // perform transformations to make it render and prettier
      return _esc(reindent(unComment(doc, content)));
    }

    function _esc(s) {
      return s.replace(/&/g,'&amp;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/</g,'&lt;');
    }

    function reindent(text) {
      // TODO: use trimEnd when Edge supports it
      const lines = text.trimRight().split("\n");
      while (lines.length && !lines[0].trim()) {
        lines.shift();
      }
      const indents = lines.filter(s => s.trim()).map(s => s.search(/[^\s]/));
      const leastIndent = Math.min(...indents);
      return lines.map(s => s.slice(leastIndent)).join("\n");
    }

    function unComment(doc, content) {
      // perform transformations to make it render and prettier
      return content
        .replace(/<!--/, '')
        .replace(/-->/, '')
        .replace(/< !\s*-\s*-/g, '<!--')
        .replace(/-\s*- >/g, '-->')
        .replace(/-\s*-\s*&gt;/g, '--&gt;');
    }
  </script>
</head>
<body>
  <section id="abstract">
    <p>TODO</p>
  </section>
  <section id="sotd">
  </section>

  <section id="introduction">
    <h1>Introduction</h1>

    <section class="informative">
      <h2>Background and Motivation</h2>

      <p>TODO, citing [[RDF-STAR-FOUNDATION]]</p>
    </section>

    <section class="informative">
      <h2>Overview</h2>

<p>The RDF data model lets you state facts in three-part subject-predicate-object statements known as triples. For example, with a single RDF triple you can say that employee38 has a familyName of "Smith". A triple's predicate is a property specified with an IRI (an Internationalized version of a URI) to identify the namespace of the property name. A triple's subject and object can each be an IRI referencing any entity, and the object can also be a literal value such as "Smith" or data of other types such as dates, numbers, or Boolean values. </p>

<p>The subject and object of a triple can themselves reference triples. In the statement "employee22 claims that employee38 has a jobTitle of 'Assistant Designer'", the object of the triple that has employee22 as its subject references the statement "employee38 has a jobTitle of 'Assistant Designer'". This use of a triple as the subject or object resource of another triple so that we can say things about that triple is known as <a href='https://www.w3.org/TR/1999/REC-rdf-syntax-19990222/#higherorder'>reification</a>. </p>
<p>The concept of reification has always been part of RDF, but expressing it in RDF concrete syntaxes such as Turtle, N-Triples, and RDF/XML has been verbose and cumbersome. This specification describes a new, more compact conceptual data model and Turtle concrete syntax for reification known as RDF* (pronounced "RDF star") and Turtle* (pronounced "Turtle star"), respectively. This model and syntax enable the creation of concise triples that reference other triples as subject and object resources.</p>

<p>Triples that include a triple as a subject or an object are known as RDF* triples. The following dataset shows the example RDF* triples from above using the Turtle* syntax, which uses double angle brackets to enclose a triple serving as a subject or object resource:</p>

      <pre data-transform="updateExample"
        data-content-type="text/x-turtle-star"
        class="nohighlight example"
      >
        <!--
@prefix :    <http://www.example.org/> .

:employee38 :familyName "Smith" .
:employee22 :claims << :employee38 :jobTitle "Assistant Designer" >> .
        -->
      </pre>

<p>After declaring a prefix so that IRIs can be abbreviated, the first triple in this example asserts that employee38 has a familyName of "Smith". Note that this dataset does not assert that employee38 has a jobTitle of "Assistant Designer"; it says that employee22 has made that claim. In other words, the triple "employee38 has a jobTitle of 'Assistant Designer'" is not what we call an asserted triple, like "employee38 has a familyName of 'Smith'" above; it is known as an embedded triple. (If we added the triple `:employee38 :jobTitle "Assistant Designer"` below the triple about employee22's claim in the example above, then this triple about employee38's jobTitle would be both an embedded triple and an asserted one.) </p>

<p>This specification also describes an extension to the SPARQL Protocol and Query Language known as SPARQL* (pronounced "SPARQL star") for the querying of RDF* triples. For example, the following SPARQL* query asks "who has made any claims about employee38?"</p>

<pre data-transform="updateExample"
     data-content-type="application/x-sparql-star-query"
     class="nohighlight example"
>
                <!--
PREFIX : <http://www.example.org/> 

SELECT ?claimer WHERE {
   ?claimer :claims << :employee38 ?property ?value >>
}
-->
</pre>


<p> SPARQL query triple patterns that include a triple pattern as a subject or object are known as SPARQL* triple patterns. </p>

<p>For the remainder of this document, examples will assume that the following prefixes have been declared to represent the IRIs shown with them here: </p>

<table>
<tr><td>`:`</td><td>`&lt;http://www.example.org/&gt;`</td></tr>
<tr><td>`rdfs:`</td><td>`&lt;http://www.w3.org/2000/01/rdf-schema#>`</td></tr>
<tr><td>`owl:`</td><td>`&lt;http://www.w3.org/2002/07/owl#>`</td></tr>
<tr><td>`prov:`</td><td>`&lt;http://www.w3.org/ns/prov#>`</td></tr>
<tr><td>`dc:`</td><td>`&lt;http://purl.org/dc/elements/1.1/>`</td></tr>
<tr><td>`dct:`</td><td>`&lt;http://purl.org/dc/terms/>`</td></tr>
</table>

    </section>

    <section id="conformance">
      <div class=issue data-number="3"></div>
    </section>

  </section>

  <section id="concepts">
    <h2>Concepts and Abstract Syntax</h2>

    <p>In the following, we we introduce a number of SPARQL*-specific definitions, which rely on the following notions (extending some of them) defined in [[[RDF11-CONCEPTS]]] [[RDF11-CONCEPTS]]:
    <dfn data-cite="RDF11-CONCEPTS#dfn-blank-node">blank node</dfn>,
    <dfn data-cite="RDF11-CONCEPTS#dfn-default-graph">default graph</dfn>,
    <dfn data-cite="RDF11-CONCEPTS#dfn-graph-name">graph name</dfn>,
    <dfn data-cite="RDF11-CONCEPTS#dfn-iri">IRI</dfn>,
    <dfn data-cite="RDF11-CONCEPTS#dfn-literal">literal</dfn>,
    <dfn data-cite="RDF11-CONCEPTS#dfn-named-graph">named graphs</dfn>,
    <dfn data-cite="RDF11-CONCEPTS#dfn-object">object</dfn>,
    <dfn data-cite="RDF11-CONCEPTS#dfn-predicate">predicate</dfn>,
    <dfn data-cite="RDF11-CONCEPTS#dfn-rdf-dataset">RDF dataset</dfn>,
    <dfn data-cite="RDF11-CONCEPTS#dfn-rdf-graph">RDF graph</dfn>,
    <dfn data-cite="RDF11-CONCEPTS#dfn-rdf-triple">RDF triple</dfn>,
    and <dfn data-cite="RDF11-CONCEPTS#dfn-subject">subject</dfn>
    </p>

    <p>An <dfn data-lt="graph">RDF* graph</dfn> is a set of <a>RDF* triples</a>.</p>

    <p>An <dfn data-lt="triple">RDF* triple</dfn> is a 3-tuple defined recursively as follows:</p>
    <ul>
      <li>any <a>RDF triple</a> is an <a>RDF* triple</a>;</li>
      <li>if |t| and <var>t'</var> are <a>RDF* triples</a>, |s| is an <a>IRI</a> or a <a>blank node</a>, |p| is an <a>IRI</a>, |o| is an <a>IRI</a>, a <a>blank node</a> or a <a>literal</a>, then (|t|, |p|, |o|), (|s|, |p|, |t|) and (|t|, |p|, <var>t'</var>) are <a>RDF* triples</a>.</li>
    </ul>

    <p>As for <a>RDF triples</a>, we call the 3 components of an <a>RDF* triple</a> its <a>subject</a>, <a>predicate</a> and <a>object</a>, respectively. From the definitions above, it follows that any <a>RDF graph</a> is also an <a>RDF* graph</a>. Note also that, by definition, an RDF* triple cannot contain itself and cannot be nested infinitely.</p>

    <p><a>IRIs</a>, <a>literals</a>, <a>blank nodes</a> and <a>RDF* triples</a> are collectively known as <dfn>RDF* terms</dfn>.</p>

    <p>For every <a>RDF* triple</a> <var>t</var>, we define its <dfn data-lt="constituent">constituent terms</dfn> (or simply constituents) as the set containing its <a>subject</a>, its <a>predicate</a>, its <a>object</a>, plus all the <a>constituent terms</a> of its <a>subject</a> and/or its <a>object</a> if they are themselves <a>RDF* triples</a>. By extension, we define the <a>constituent terms</a> of an <a>RDF* graph</a> to be the union set of the <a>constituent terms</a> of all its triples.</p>

    <div class="example">
      Consider the following <a>RDF* triple</a> (represented in Turtle*):
      <pre data-transform="updateExample"
        data-content-type="text/x-turtle-star"
        class="nohighlight example"
      >
        <!--
        << _:a :name "Alice" >> :statedBy :bob.
        -->
      </pre>
      Its set of <a>constituent terms</a> comprises the <a>IRIs</a> `:name`, `:statedBy`, `:bob`, the <a>blank node</a> `_:a`, the <a>literal</a> `"Alice"`, and the <a>triple</a> `&lt;&lt; _:a :name "Alice" >>`.
    </div>

    <p>An <a>RDF* triple</a> used as the <a>subject</a> or <a>object</a> of another <a>RDF* triple</a> is called an <dfn data-lt="embedded">embedded triple</dfn>. An <a>RDF* triple</a> that is an element of an <a>RDF* graph</a> is called an <dfn data-lt="asserted">asserted triple</dfn>. Note that, in a given <a>RDF* graph</a>, the same <a>triple</a> MAY be both <a>embedded</a> and <a>asserted</a>.</p>

    <p>An <dfn data-lt="dataset">RDF* dataset</dfn> is a collection of <a>RDF* graphs</a>, and comprises:</p>

    <ul>
      <li>Exactly one <a>default graph</a>, being an <a>RDF* graph</a>. The <a>default graph</a> does not have a name and MAY be empty.</li>
      <li>Zero or more <a>named graphs</a>. Each <a>named graph</a> is a pair consisting of either an <a>IRI</a> or a <a>blank node</a> (called the <a>graph name</a>), and an <a>RDF* graph</a>. <a>Graph names</a> are unique within an <a>RDF* dataset</a>.</li>
    </ul>

    <p>Again, this definition is an extension of the notion of <a>RDF dataset</a>, hence it follows that any <a>RDF dataset</a> is also an <a>RDF* dataset</a>.</p>
  </section>

  <section id="turtle-star">
    <h2>Turtle*</h2>
    <p>In this section, we present Turtle*, an extension of the Turtle format [[TURTLE]] allowing the representation of <a>RDF* graphs</a>. For the sake of conciseness, we only describe here the differences between Turtle* and Turtle.</p>

    <section id="turtle-star-grammar">
      <h2>Grammar</h2>
      <p>Turtle* is defined to follow the <a data-cite="TURTLE#h3_sec-grammar-grammar">same grammar</a> as Turtle, <em>except</em> for the <a data-cite="XML#sec-notation"><abbr title="Extended Backus-Naur Form">EBNF</abbr> productions</a> specified below, which replace the productions having the same number (if any) in the original grammar.</p>

      <table class="grammar">
        <tr id="grammar-production-objectList">
          <td>[8]</td>
          <td>`objectList`</td>
          <td>::=</td>
          <td>
            <a href="#grammar-production-object">object</a>
            <a href="#grammar-production-annotation">annotation</a>`?`
            `(`
            <code class="grammar-literal">','</code>
            <a href="#grammar-production-object">object</a>
            <a href="#grammar-production-annotation">annotation</a>`?`
            `)*`
          </td>
        </tr>
        <tr id="grammar-production-subject">
          <td>[10]</td>
          <td>`subject`</td>
          <td>::=</td>
          <td>
            <a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a data-cite="TURTLE#grammar-production-collection">collection</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-object">
          <td>[12]</td>
          <td>`object`</td>
          <td>::=</td>
          <td>
            <a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a  data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a  data-cite="TURTLE#grammar-production-collection">collection</a> `|`
            <a data-cite="TURTLE#grammar-production-blankNodePropertyList">blankNodePropertyList</a> `|`
            <a data-cite="TURTLE#grammar-production-literal">literal</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-embTriple">
          <td>[27]</td>
          <td>`embTriple`</td>
          <td>::=</td>
          <td>
            <code class="grammar-literal">'&lt;&lt;'</code>
            <a href="#grammar-production-embSubject">embSubject</a>
            <a data-cite="TURTLE#grammar-production-verb">verb</a>
            <a href="#grammar-production-embObject">embObject</a>
            <code class="grammar-literal">'&gt;&gt;'</code>
          </td>
        </tr>
        <tr id="grammar-production-embSubject">
          <td>[28]</td>
          <td>`embSubject`</td>
          <td>::=</td>
          <td>
            <a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a  data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-embObject">
          <td>[29]</td>
          <td>`embObject`</td>
          <td>::=</td>
          <td>
            <a data-cite="TURTLE#grammar-production-iri">iri</a> `|`
            <a  data-cite="TURTLE#grammar-production-BlankNode">BlankNode</a> `|`
            <a data-cite="TURTLE#grammar-production-literal">literal</a> `|`
            <a href="#grammar-production-embTriple">embTriple</a>
          </td>
        </tr>
        <tr id="grammar-production-annotation">
          <td>[31]</td>
          <td>`annotation`</td>
          <td>::=</td>
          <td>
            <code class="grammar-literal">'{|'</code>
            <a  data-cite="TURTLE#grammar-production-predicateObjectList">predicateObjectList</a>
            <code class="grammar-literal">'|}'</code>
          </td>
        </tr>
      </table>

      <p class="note">The changes are that <a href="#grammar-production-subject">`subject`</a> and <a href="#grammar-production-object">`object`</a> productions have been extended to accept <a>embedded triples</a>, which are described by the new productions <a href="#grammar-production-embTriple">27</a> to <a href="#grammar-production-embObject">29</a>. Note that <a>embedded triples</a> accept a more restricted range of <a>subject</a> and <a>object</a> expressions than <a>asserted triples</a>. Additionally, the <a href="#grammar-production-objectList">`objectList`</a> production now accepts an optional <a href="#grammar-production-annotation">annotation</a> after each object.</p>

      <div class="issue" data-number="9"></div>
    </section>

    <section>
      <h2>Parsing</h2>
      <p>A Turtle* parser is similar to a Turtle parser as defined in <a data-cite="TURTLE#h2_sec-parsing">Section 7 of the Turtle specification</a> [[TURTLE]], with an additional item in its state:</p>
      <ul>
        <li id="curObject"><a>RDF* Term</a> |curObject| — The |curObject| is bound to the <a href="#grammar-production-embObject">`embObject`</a> production.</li>
      </ul>
      <p>Additionally, the <a data-cite="TURTLE#curSubject">|curSubject|</a> can be bound to any <a>RDF* term</a> (including an <a>embedded triple</a>).</p>

      <p>A Turtle* document defines an <a>RDF* graph</a> composed of a set of <a>RDF* triples</a>. The <a href="#grammar-production-subject">`subject`</a> and <a href="#grammar-production-embSubject">`embSubject`</a> productions set the |curSubject|. The <a data-cite="TURTLE#grammar-production-verb">`verb`</a> production sets the <a data-cite="TURTLE#curPredicate">|curPredicate|</a>. The <a href="#grammar-production-object">`object`</a> and <a href="#grammar-production-embObject">`embObject`</a> productions set the |curObject|. Finishing the <a href="#grammar-production-object">`object`</a> production, an <a>RDF* triple</a> |curSubject| |curPredicate| |curObject| is generated and added to the <a>RDF* graph</a>.</p>

      <p>Beginning the <a href="#grammar-production-embTriple">`embTriple`</a> production records the |curSubject| and |curPredicate|. Finishing the <a href="#grammar-production-embTriple">`embTriple`</a> production yields the <a>RDF* triple</a> |curSubject| |curPredicate| |curObject| and restores the recorded values of |curSubject| and |curPredicate|.</p>

      <p>Beginning the <a href="#grammar-production-annotation">`annotation`</a> production records the |curSubject| and |curPredicate|, and sets the |curSubject| to the <a>RDF* triple</a> |curSubject| |curPredicate| |curObject|. Finishing the <a href="#grammar-production-annotation">`annotation`</a> production restores the recorded values of |curSubject| and |curPredicate|.</p>

      <p>All other productions MUST be handled as specified by <a data-cite="TURTLE#h2_sec-parsing">Section 7 of the Turtle specification</a> [[TURTLE]], while still applying the changes above recursively.</p>
    </section>

    <section class="informative">
      <h2>Other Concrete Syntaxes</h2>

      <p>While this document specifies only one concrete syntax, nothing prevents other concrete syntaxes of RDF* from being proposed. In particular, other existing concrete syntaxes for RDF, such as RDF/XML [[RDF-SYNTAX-GRAMMAR]], could be extended to support RDF*. In particular, the N-Triples syntax [[N-TRIPLES]] being a subset of Turtle, an appropriate subset of Turtle* could be defined to extend N-Triples accordingly.</p>
    </section>

  </section>

  <section>
    <h2>SPARQL* Query Language</h2>

    <p>This Section introduces SPARQL*, which is an RDF*-aware extension of the RDF query language SPARQL [[SPARQL11-QUERY]]; i.e., SPARQL* can be used to query RDF* graphs.</p>

    <section>
      <h2>Initial Definitions</h2>

      <p>In the following, we introduce a number of SPARQL*-specific definitions, which rely on the following notions, defined in [[[SPARQL11-QUERY]]] [[SPARQL11-QUERY]]: <dfn data-cite="SPARQL11-QUERY#defn_RDFTerm">RDF term</dfn>, <dfn data-cite="SPARQL11-QUERY#defn_QueryVariable" data-lt="variable">query variable</dfn>, <dfn data-cite="SPARQL11-QUERY#defn_TriplePattern">triple pattern</dfn>,
      <dfn data-cite="SPARQL11-QUERY#defn_PropertyPathPattern">property path pattern</dfn>,
      <dfn data-cite="SPARQL11-QUERY#defn_PropertyPathExpr">property path expression</dfn>,
      and <dfn data-cite="SPARQL11-QUERY#defn_sparqlSolutionMapping">solution mapping</dfn>.</p>

      <p>A <dfn data-lt="triple-star-pattern">SPARQL* triple pattern</dfn> is a 3-tuple that is defined recursively as follows:</p>
      <ol>
        <li>Every SPARQL <a>triple pattern</a> is a SPARQL* triple pattern;
        <li>If |t| and <var>t'</var> are SPARQL* triple patterns, |x| is an <a>RDF term</a> or a <a>query variable</a>, and |p| is an <a>IRI</a> or a <a>query variable</a>, then (|t|,&nbsp;|p|,&nbsp;|x|), (|x|,&nbsp;|p|,&nbsp;|t|), and (|t|,&nbsp;|p|,&nbsp;<var>t'</var>) are SPARQL* triple patterns.
      </ol>

      <p>As for <a>RDF* triples</a>, a <a>SPARQL* triple pattern</a> MUST NOT contain itself.</p>

      <p>A <dfn data-lt="bgp-star|BGP*">SPARQL* basic graph pattern</dfn> (<abbr title="Basic Graph Pattern">BGP</abbr>*) is a set of <a>SPARQL* triple patterns</a>.</p>

      <p>A <dfn data-lt="ppp-star">SPARQL* property path pattern</dfn> is a 3-tuple (|s|,|p|,|o|) where</p>
      <ul>
        <li>|s| is either an <a>RDF term</a>, a <a>query variable</a>, or a <a>SPARQL* triple pattern</a>,
        <li>|p| is a <a>property path expression</a>, and
        <li>|o| is either an <a>RDF term</a>, a <a>query variable</a>, or a <a>SPARQL* triple pattern</a>.
      </ul>

      <div class="issue" data-number="7"></div>

      <p>A <dfn data-lt="solution-star-mapping">SPARQL* solution mapping</dfn> μ is a partial function from the set of all <a>query variables</a> to the set of all <a>RDF* terms</a>.
      The domain of μ, denoted by dom(μ), is the set of <a>query variables</a> for which μ is defined.</p>

      <p class="note">The notion of a <a>SPARQL* solution mapping</a> extends the notion of a standard SPARQL <a>solution mapping</a>; that is, every SPARQL <a>solution mapping</a> is a <a>SPARQL* solution mapping</a>. However, in contrast to SPARQL <a>solution mappings</a>, <a>SPARQL* solution mappings</a> may map <a>variables</a> also to <a>RDF* triples</a>.</p>

      <p>All notions related to SPARQL solution mappings carry over naturally to SPARQL* solution mappings. In particular, the definition of <dfn data-cite="SPARQL11-QUERY#defn_algCompatibleMapping">compatibility</dfn> extends naturally to SPARQL* solution mappings: two <a>SPARQL* solution mappings</a> μ<sub>1</sub> and μ<sub>2</sub> are compatible if, for every variable v that is both in dom(μ<sub>1</sub>) and in dom(μ<sub>2</sub>), μ<sub>1</sub>(v) and μ<sub>2</sub>(v) are the same <a>RDF* term</a>.
      In this case, μ<sub>1</sub> ∪ μ<sub>2</sub> is also a SPARQL* solution mapping.
      Moreover, for any SPARQL* solution mapping&nbsp;μ we write card[Ω](μ) to denote the cardinality of μ in a multiset Ω of such mappings.
      Finally, given a <a>BGP*</a>&nbsp;|B| and a SPARQL* solution mapping&nbsp;μ, we write μ(|B|) to denote the result of replacing every variable&nbsp;|v| in |B| for which μ is defined with μ(v).
      </p>

      <p>Next, we aim to carry over the notion of <a data-cite="SPARQL11-QUERY#BGPsparql">solutions for BGPs</a> to <a>BGP*</a>. To this end, we first define an auxiliary concept that carries over the notion of an
      <a data-cite="RDF11-MT#dfn-instance">RDF instance mapping</a> [[RDF11-MT]] to RDF*.</p>

      <p>An <dfn data-lt="rdf-star-instance-mapping">RDF* instance mapping</dfn>&nbsp;σ is a partial function from the set of all <a>blank nodes</a> to the set of all <a>RDF* terms</a>.
      The domain of&nbsp;σ, denoted by dom(σ), is the set of <a>blank nodes</a> for which σ is defined.</p>

      <p>Similar to the corresponding notation for solution mappings, for an RDF* instance mapping&nbsp;σ and a BGP*&nbsp;|B| we write σ(|B|) to denote the result of replacing every blank node&nbsp;|b| in |B| for which σ is defined with σ(b).</p>

      <p>Now we are ready to define the notion of solution for BGP*.</p>

      <p>Given a <a>BGP*</a>&nbsp;|B| and an <a>RDF* graph</a>&nbsp;|G|, a <a>SPARQL* solution mapping</a>&nbsp;μ is a <dfn data-lt="bgp-star-solution">solution for the BGP*</dfn>&nbsp;|B| <b>over</b>&nbsp;|G| if it has the following two properties</p>
      <ul>
        <li>dom(μ) is equivalent to the set of query variables in&nbsp;|B|, and
        <li>there exists an <a>RDF* instance mapping</a>&nbsp;σ such that dom(σ) is equivalent to the set of blank nodes in&nbsp;|B| and μ(σ(|B|)) is a subgraph of |G|.
      </ul>

    </section>

    <section id="sparql-star-grammar">
      <h2>Grammar</h2>

      <p>SPARQL* is defined to follow the <a data-cite="SPARQL11-QUERY#sparqlGrammar">same grammar</a> as SPARQL, <em>except</em> for the <a data-cite="XML#sec-notation"><abbr title="Extended Backus-Naur Form">EBNF</abbr> productions</a> specified below, which replace the productions having the same number (if any) in the original grammar.</p>

      <table class="grammar">
        <tr id="rBind">
          <td>[60]</td>
          <td>`Bind`</td>
          <td>::=</td>
          <td>
            <code class="token">'BIND'</code>
            <code class="token">'('</code>
            (
              <a data-cite="SPARQL11-QUERY#rExpression">Expression</a> `|`
              <a href="#rEmbTP">EmbTP</a>
            )
            <code class="token">'AS'</code>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a>
            <code class="token">')'</code>
          </td>
        </tr>
          <tr id="rTriplesSameSubject">
          <td>[75]</td>
          <td>`TriplesSameSubject`</td>
          <td>::=</td>
          <td>
            <a href="#rVarOrTermOrEmbTP">VarOrTermOrEmbTP</a>
            <a data-cite="SPARQL11-QUERY#rPropertyListNotEmpty">PropertyListNotEmpty</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rTriplesNode">TriplesNode</a>
            <a data-cite="SPARQL11-QUERY#rPropertyList">PropertyList</a>
        </td>
        <tr id="rObject">
          <td>[80]</td>
          <td>`Object`</td>
          <td>::=</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rGraphNode">GraphNode</a> `|`
            <a href="#rEmbTP">EmbTP</a>
          </td>
        </tr>
        <tr id="rTriplesSameSubjectPath">
          <td>[81]</td>
          <td>`TriplesSameSubjectPath`</td>
          <td>::=</td>
          <td>
            <a href="#rVarOrTermOrEmbTP">VarOrTermOrEmbTP</a>
            <a data-cite="SPARQL11-QUERY#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a>
            `|`
            <a data-cite="SPARQL11-QUERY#rTriplesNode">TriplesNode</a>
            <a data-cite="SPARQL11-QUERY#rPropertyListPath">PropertyListPath</a>
          </td>
        </tr>
        <tr id="rGraphNodePath">
          <td>[105]</td>
          <td>`GraphNodePath`</td>
          <td>::=</td>
          <td>
            <a href="#rVarOrTermOrEmbTP">VarOrTermOrEmbTP</a> `|`
            <a data-cite="SPARQL11-QUERY#rTriplesNodePath">TriplesNodePath</a> `|`
          </td>
        </tr>
        <tr id="rEmbTP">
          <td>[174]</td>
          <td>`EmbTP`</td>
          <td>::=</td>
          <td>
            <code class="token">'&lt;&lt;'</code>
            <a href="#rEmbSubjectOrObject">EmbSubjectOrObject</a>
            <a data-cite="SPARQL11-QUERY#rVerb">Verb</a>
            <a href="#rEmbSubjectOrObject">EmbSubjectOrObject</a>
            <code class="token">'&gt;&gt;'</code>
          </td>
        </tr>
        <tr id="rEmbSubjectOrObject">
          <td>[175]</td>
          <td>`EmbSubjectOrObject`</td>
          <td>::=</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a> `|`
            <a data-cite="SPARQL11-QUERY#rBlankNode">BlankNode</a> `|`
            <a data-cite="SPARQL11-QUERY#riri">iri</a> `|`
            <a data-cite="SPARQL11-QUERY#rRDFLiteral">RDFLiteral</a> `|`
            <a data-cite="SPARQL11-QUERY#rNumericLiteral">NumericLiteral</a> `|`
            <a data-cite="SPARQL11-QUERY#rBooleanLiteral">BooleanLiteral</a> `|`
            <a href="#rEmbTP">EmbTP</a>
          </td>
        </tr>
        <tr id="rVarOrTermOrEmbTP">
          <td>[176]</td>
          <td>`VarOrTermOrEmbTP`</td>
          <td>::=</td>
          <td>
            <a data-cite="SPARQL11-QUERY#rVar">Var</a> `|`
            <a data-cite="SPARQL11-QUERY#rGraphTerm">GraphTerm</a> `|`
            <a href="#rEmbTP">EmbTP</a>
          </td>
        </tr>
      </table>

      <p>
        This introduces a notation for <dfn>embedded triple patterns</dfn>
        (productions <a href="#rEmbTP">[174]</a> and following),
        which is similar to the one defined for <a>embedded triples</a> in <a href="#turtle-star"></a>,
        but accepting also <a>variables</a>.
        These <a>embedded triple patterns</a> are allowed in the subject
        (<a href="#rTriplesSameSubject">[75]</a>, <a href="#rTriplesSameSubjectPath">[81]</a>)
        and object
        (<a href="#rObject">[80]</a>, <a href="#rGraphNodePath">[105]</a>)
        positions of <a>SPARQL* triple patterns</a>,
        as well as in BIND statements
        (<a href="#rBind">[60]</a>).
      </p>

      <div class="issue" data-number="6"></div>

    </section>

    <section>
      <h2>Translation to the Algebra</h2>

      <p>Based on the SPARQL grammar, the SPARQL specification <q>defines the process of converting graph patterns and solution modifiers in a SPARQL query string into a SPARQL algebra expression</q> [<a data-cite="SPARQL11-QUERY#sparqlQuery">SPARQL11-QUERY, Section 18.2</a>].  This process must be adjusted to consider the extended grammar introduced <a href="#sparql-star-grammar">above</a>. In the following, any step of the conversion process that requires adjustment is discussed.</p>

      <section>
        <h2>Variable Scope</h2>

        <p>As a basis of the translation, the SPARQL specification introduces a notion of <a data-cite="SPARQL11-QUERY#variableScope">in-scope variables</a>. To cover the new syntax elements introduced in <a href="#sparql-star-grammar"></a> this notion MUST be extended as follows.</p>

        <ul>
          <li>A <a>variable</a> is in-scope of a <a>BGP*</a> |B| if the <a>variable</a> occurs in |B|, which includes an occurrence in any <a>embedded triple pattern</a> in |B| (independent of the level of nesting).</li>
          <li>A <a>variable</a> is in-scope of a <a>property path pattern</a> if the variable occurs in that pattern, which includes an occurrence in any embedded triple pattern in the pattern (independent of the level of nesting).</li>
          <li>A <a>variable</a> is in-scope of a BIND clause of the form `BIND ( T AS v )` (where |T| is an <a>embedded triple pattern</a>) if the variable is variable |v| or the variable occurs in the <a>embedded triple pattern</a> |T|. As for standard BIND clauses with expressions, variable |v| must <q>not [be] in-scope from the preceding elements in the group graph pattern in which [the BIND clause] is used</q> [<a data-cite="SPARQL11-QUERY#variableScope">SPARQL11-QUERY, Section 18.2.1]</a>].</li>
        </ul>
      </section>

      <section>
        <h2>Expand Syntax Forms</h2>

        <p>The translation process starts with expanding <q>abbreviations for IRIs and triple patterns</q> [<a data-cite="SPARQL11-QUERY#sparqlExpandForms">SPARQL11-QUERY, Section 18.2.2.1</a>]. This step MUST be extended in two ways:</p>

        <ol>
          <li><div>
            <p>Abbreviations for <a>triple patterns</a> with <a>embedded triple patterns</a> MUST be expanded as if each <a>embedded triple pattern</a> was a <a>variable</a> (or an <a>RDF term</a>).

            <div class="example">
              For instance, the following syntax expression:
              <pre data-transform="updateExample"
                data-content-type="application/x-sparql-star-query"
                class="nohighlight example"
              >
                <!--
                <<?c a rdfs:Class>> dct:source ?src ;
                    prov:wasDerivedFrom <<?c a owl:Class>> .
                -->
              </pre>
              must be expanded to
              <pre data-transform="updateExample"
                data-content-type="application/x-sparql-star-query"
                class="nohighlight example"
              >
                <!--
                <<?c a rdfs:Class>> dct:source ?src .
                <<?c a rdfs:Class>> prov:wasDerivedFrom <<?c a owl:Class>> .
                -->
              </pre>
            </div>
          </div></li>
          <li><div>
            <p>Abbreviations for IRIs in all <a>embedded triple patterns</a> MUST be expanded.</p>

            <div class="example">
              For instance, the embedded triple pattern
              <pre data-transform="updateExample"
                data-content-type="application/x-sparql-star-query"
                class="nohighlight example"
              >
                <!--
                <<?c a rdfs:Class>>
                -->
              </pre>
              must be expanded to
              <pre data-transform="updateExample"
                data-content-type="application/x-sparql-star-query"
                class="nohighlight example"
              >
                <!--
                <<?c <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/2000/01/rdf-schema#Class>>>
                -->
              </pre>
            </div>
          </div></li>
        </ol>
      </section>

      <section>
        <h2>Translate Property Path Patterns</h2>

        <p>The <a data-cite="SPARQL11-QUERY#sparqlTranslatePathPatterns">translation of property path patterns</a> has to be adjusted because the extended grammar allows for <a>SPARQL* property path patterns</a> whose subject or object is a <a>SPARQL* triple pattern</a>.</p>

        <p>The translation as specified in the W3C specification distinguishes four cases. The first three of these cases do not require adjustment because they are taken care of either by recursion or by the adjusted translation of basic graph patterns (as defined in <a href="#translate-bgp"></a> below). However, the fourth case MUST be adjusted as follows.</p>

        <p>Let |X| |P| |Y| be a string that corresponds to the fourth case in [<a data-cite="SPARQL11-QUERY#sparqlTranslatePathPatterns">SPARQL11-QUERY, Section 18.2.2.4</a>]. Given the grammar introduced in <a href="#sparql-star-grammar"></a>, |X| and |Y| may be an <a>RDF term</a>, a <a>variable</a>, or an <a>embedded triple pattern</a>, respectively (and |P| is a <a>property path expression</a>). The string |X| |P| |Y| is translated to the algebra expression `Path`(<var>X’</var>,|P|,<var>Y’</var>) where <var>X’</var> and <var>Y’</var> are the result of calling a function named `Lift` for |X| and |Y|, respectively. For some input string |Z| (such as |X| or |Y|) that can be an <a>RDF term</a>, a <a>variable</a>, or an <a>embedded triple pattern</a>, the function `Lift` is defined recursively as follows:</p>

        <ol id="lift">
          <li>If |Z| is an <a>embedded triple pattern</a> &lt;&lt;|S|,|P|,|O|&gt;&gt; then return the <a>SPARQL* triple pattern</a> (`Lift`(|S|), |P|, `Lift`(|O|));</li>
          <li>Otherwise, return |Z|.</li>
        </ol>

        <div class="note">
          The purpose of this translation step is to convert any property path pattern as can be written based on the extended grammar for SPARQL* (cf. <a href="#sparql-star-grammar"></a>) into a <a>SPARQL* property path pattern</a> as considered in the algebra. To this end, the function `Lift` translates every <a>embedded triple pattern</a> as can be written in the SPARQL* syntax into a <a>SPARQL* triple pattern</a>.
        </div>
      </section>

      <section id="translate-bgp">
        <h2>Translate Basic Graph Patterns</h2>

        <p>After translating <a>property path patterns</a>, the translation process collects <q>any adjacent triple patterns [...] to form a basic graph pattern</q> [<a data-cite="SPARQL11-QUERY#sparqlTranslateBasicGraphPatterns">SPARQL11-QUERY, Section 18.2.2.5</a>]. This step has to be adjusted because <a>triple patterns</a> in the extended syntax may have an <a>embedded triple pattern</a> in their subject position or in their object position (or in both). To ensure that every result of this step is a <a>BGP*</a>, before adding a <a>triple pattern</a> to its corresponding collection, its subject and object MUST be replaced by the result of calling <a href="#lift">function `Lift`</a> for the subject and the object, respectively.</p>
      </section>

      <section id="translate-bind">
        <h2>Translate BIND Clauses with an Embedded Triple Pattern</h2>

        <p>The extended grammar in <a href="#sparql-star-grammar"></a> allows for BIND clauses with an <a>embedded triple pattern</a>. The translation of such a BIND clause to a SPARQL algebra expression requires a new algebra symbol:</p>

        <ul>
          <li>TR( <a>SPARQL* triple pattern</a>, <a>variable</a> )</li>
        </ul>

        <p>Then, any string of the form `BIND( T AS v )` with |T| being an <a>embedded triple pattern</a> (i.e., not a standard BIND expression) is translated to the algebra expression `TR`(<var>T’</var>, |v|) where <var>T’</var> is the result of the <a href="#lift">function `Lift`</a> for |T|.</p>

        <p>Notice, the translation of BIND clauses with an <a>embedded triple pattern</a> as defined in this section is used during <a data-cite="SPARQL11-QUERY#sparqlTranslateGraphPatterns">the translation of group graph patterns</a>. The case of BIND clauses with an <a>embedded triple pattern</a> is covered in this translation of group graph patterns by the last, “catch all other” `IF` statement (i.e., the `IF` statement with the condition `E is any other form`) and not by the `IF` statement for BIND clauses with an expression.</p>
      </section>
    </section>

    <section>
      <h2>Evaluation Semantics</h2>

      <p>The SPARQL specification defines a function <q>eval(|D|(|G|), algebra expression) as the evaluation of an algebra expression with respect to a dataset |D| having active graph |G|</q> [<a data-cite="SPARQL11-QUERY#sparqlAlgebraEval">SPARQL11-QUERY, Section 18.6</a>]. Recall that the dataset |D| in the context of SPARQL* is an <a>RDF* dataset</a> and, thus, the active graph |G| is an <a>RDF* graph</a>, and so is any other graph in dataset |D|. The definition of the <a data-cite="SPARQL11-QUERY#sparqlAlgebraEval">eval</a> function is recursive; the two base cases of this definition for SPARQL* are given as follows:</p>

      <ol>
        <li>For every <a>BGP*</a> |B|, eval(|D|(|G|), |B|) is a multiset Ω that consists of all <a>SPARQL* solution mappings</a> that are a <a>solution for the BGP*</a>&nbsp;|B| over&nbsp;|G|. For every such mapping&nbsp;μ, card[Ω](μ) is the number of distinct <a>RDF* instance mappings</a>&nbsp;σ such that dom(σ) is equivalent to the set of blank nodes in&nbsp;|B| and μ(σ(|B|)) is a subgraph of |G|. (For any SPARQL* solution mapping&nbsp;μ' that is <em>not</em> a solution for&nbsp;|B| over&nbsp;|G|, we have that card[Ω](μ')=0; i.e., μ' is not in Ω.)</li>

        <li>For any algebra expression |E| of the form TR(|tp|, <var>?v</var>) where |tp| is a <a>SPARQL* triple pattern</a> and <var>?v</var> is a <a>variable</a> (as introduced in <a href="#translate-bind"></a>), eval(|D|(|G|), |E|) is a multiset Ω that consists of as many <a>SPARQL* solution mappings</a> as there are solution mappings in Ω', where Ω'=eval(|D|(|G|),{|tp|}), such that for every μ' in Ω' there exists a μ in Ω that has the following four properties:
          <ol type="i">
            <li>dom(μ) = dom(μ') ∪ {<var>?v</var>}</li>
            <li>μ and μ' are compatible</li>
            <li>μ(<var>?v</var>) = μ'(|tp|)</li>
            <li>card[Ω](μ) = card[Ω'](μ')</li>
          </ol>
        </li>
      </ol>

      <p>For any other algebra expression, the SPARQL specification defines algebra operators [[SPARQL11-QUERY]]. These definitions can be extended naturally to operate over multisets of <a>SPARQL* solution mappings</a> (instead of ordinary <a>solution mappings</a>). Given this extension, the recursive steps of the definition of the <a data-cite="SPARQL11-QUERY#sparqlAlgebraEval">eval</a> function for SPARQL* are the same as in the SPARQL specification.</p>
    </section>

    <section>
      <h2>Query Result Formats</h2>

      <p>In SPARQL, queries can take four forms: <em>SELECT</em>, <em>CONSTRUCT</em>, <em>DESCRIBE</em>, and <em>ASK</em> - see <a data-cite="SPARQL11-QUERY#QueryForms">SPARQL1.1 Query, Section 16</a> [[SPARQL11-QUERY]]. The first of these returns a <a data-cite="SPARQL11-QUERY#defn_sparqlSolutionSequence">sequence of solution mappings</a> that contain variable bindings. The second and third both return an RDF graph, and the last returns a boolean value.
      </p>
      <p>The result of the <em>ASK</em> query form is not changed by the introduction of RDF*, and the result of the <em>CONSTRUCT</em> and <em>DESCRIBE</em> forms can be represented by <a href="#turtle-star">Turtle*</a>. However, since the <em>SELECT</em> form deals with returning individual RDF terms, the specific serialization formats for representing such query results need to be extended so that the new <a>embedded</a> triple RDF term can be represented. In this section, we propose extensions for the two most common formats for this purpose: [[[sparql11-results-json]]], and [[[rdf-sparql-XMLres]]].</p>

      <div class="issue" data-number="43"></div>

      <section>
        <h2>SPARQL* Query Results JSON Format</h2>
        <p>
        The result of a SPARQL SELECT query is serialized in JSON as defined in [[[sparql11-results-json]]], which specifies a JSON representation of variable bindings to RDF terms (see [<a data-cite="sparql11-results-json#select-results">sparql11-results-json, Section 3.2</a>]). To accommodate the new RDF term for <a>embedded</a> triples that RDF* introduces, the table of RDF term JSON representations in  <a data-cite="sparql11-results-json#select-encode-terms">sparql11-results-json, Section 3.2.2</a> is extended with the following entry:
        </p>
        <dl>
            <dt>An <a>embedded</a> triple with subject RDF term `S`, predicate RDF term `P` and object RDF term `O`</dt>
            <dd>
              <pre>
                {
                  "type": "triple",
                  "value": {
                     "subject": S,
                     "predicate": P,
                     "object": O
                  }
                }
              </pre>
              where `S`, `P` and `O` are encoded using the same format, recursively.
            </dd>
          </dl>
        <div class="example">
            Consider the following RDF term, an <a>embedded</a> triple in Turtle* syntax:
          <pre data-transform="updateExample"
            data-content-type="text/x-turtle-star"
            class="nohighlight example"
          >
            <!--
            << <http://example.org/alice> <http://example.org/name> "Alice" >>
            -->
          </pre>
          This term is represented in JSON as follows:
          <pre class="example">
                {
                  "type": "triple",
                  "value": {
                     "subject": {
                        "type": "uri",
                        "value" "http://example.org/alice"
                     },
                     "predicate": {
                        "type": "uri",
                        "value" "http://example.org/name"
                     },
                     "object": {
                        "type": "literal",
                        "value" "Alice",
                        "datatype": "http://www.w3.org/2001/XMLSchema#string"
                     },
                  }
                }
          </pre>
        </div>
      <!-- <div class="issue" data-number="13"></div> -->
      </section>

      <section>
        <h2>SPARQL* Query Results XML Format</h2>
       <p>
        The result of a SPARQL SELECT query is serialized in XML as defined in [[[rdf-sparql-XMLres]]]. This format proposes an XML representation of variable bindings to RDF terms.
       </p>
       <p>To accommodate the new RDF term for <a>embedded</a> triples that RDF* introduces, the list of RDF terms and their XML representations in [<a href="rdf-sparql-XMLres#results">rdf-sparql-XMLres, Section 2.3.1</a>] is extended as follows:
        </p>
        <p>
        <dl>
            <dt>An <a>embedded</a> triple with subject term `S`, predicate term `P`, and object term `O`</dt>
          <dd>
            <pre data-transform="updateExample" class="xml">
              <!--
              <binding>
                <triple>
                  <subject>S</subject>
                  <predicate>P</predicate>
                  <object>O</object>
                </triple>
              </binding>
              -->
            </pre>
            where `S`, `P` and `O` are encoded recursively, using the same format, without the enclosing `&lt;binding&gt;` tag.
          </dd>
        </dl>
        <div class="example">
            Consider the following RDF term, an <a>embedded</a> triple in Turtle* syntax:
          <pre data-transform="updateExample"
            data-content-type="text/x-turtle-star"
            class="nohighlight example"
          >
            <!--
            << <http://example.org/alice> <http://example.org/name> "Alice" >>
            -->
          </pre>
          This term is represented in XML as follows:
          <pre data-transform="updateExample" class="xml example">
            <!--
            <triple>
                <subject>
                    <uri>http://example.org/alice</uri>
                </subject>
                <predicate>
                    <uri>http://example.org/name</uri>
                </predicate>
                <object>
                    <literal datatype='http://www.w3.org/2001/XMLSchema#string'>Alice</literal>
                </object>
            </triple>
            -->
          </pre>
        </div>

        <!-- <div class="issue" data-number="12"></div> -->

      </section>

    </section>

  </section>

  <section>
    <h2>SPARQL* Update</h2>

    <div class="issue" data-number="14"></div>

  </section>

  <section>
    <h2>RDF* Semantics</h2>

    <p>In this section, we provide a model-theoretic semantics for RDF*, based on the one defined in [[[RDF11-MT]]] [[RDF11-MT]]. More precisely, we define a mapping from RDF*'s abstract syntax into standard RDF's abstract syntax, as well as a <a>semantic extension</a> accounting for RDF* specifities.</p>

    <p>The key idea of this semantics is that <a>embedded triples</a> simply denote themselves. The rationale is that RDF* allows to annotate or talk about triples, hence triples become elements of the domain of discourse.</p>

    <p>In the following, we introduce a number of RDF*-specific definitions, which rely on the following notions, defined in [[[RDF11-CONCEPTS]]] [[RDF11-CONCEPTS]] and [[[RDF11-MT]]] [[RDF11-MT]]:
      <dfn data-cite="RDF11-CONCEPTS#dfn-datatype">datatype</dfn>,
      <dfn data-cite="RDF11-MT#dfn-ground">ground</dfn>,
      <dfn data-cite="RDF11-CONCEPTS#dfn-lexical-form">lexical form</dfn>,
      <dfn data-cite="RDF11-CONCEPTS#dfn-lexical-space">lexical space</dfn>,
      <dfn data-cite="RDF11-CONCEPTS#dfn-lexical-to-value-mapping">lexical-to-value mapping</dfn>,
      <dfn data-cite="RDF11-MT#dfn-rdf-interpretation">RDF interpretation</dfn>,
      <dfn data-cite="RDF11-MT#dfn-recognize" data-lt="recognized|recognizing">recognize</dfn>,
      <dfn data-cite="RDF11-MT#dfn-semantic-extension">semantic extension</dfn>,
      <dfn data-cite="RDF11-CONCEPTS#dfn-simple-literal">simple literal</dfn>,
      and <dfn data-cite="RDF11-CONCEPTS#dfn-value-space">value space</dfn>.
    </p>

    <section>
      <h2>Definitions</h2>

      <p>We consider five specific <a>IRIs</a> <var>D*</var>, <var>S*</var>, <var>P*</var>, <var>O*</var> and <var>I*</var> that will have a special semantics in RDF*.</p>

      <p>We introduce a new <a>datatype</a>, denoted by the <a>IRI</a> <var>D*</var>, and defined as follow:</p>
      <ul>
        <li>its <a>value space</a> is the union of the set of <a>IRIs</a> with the set of <a>Literals</a>.</li>
        <li>its <a>lexical space</a> is the set of strings satisfying the <a data-cite="N-TRIPLES#grammar-production-IRIREF">`IRIREF`</a> or <a data-cite="N-TRIPLES#grammar-production-literal">`literal`</a> production rules of the N-Triples grammar [[N-TRIPLES]], furthermore complying with the <a data-cite="N-TRIPLES#h2_canonical-ntriples">canonical form</a>, and having either an explicit datatype or language tag for `literal` (i.e., no <a>simple literal</a>).</li>
        <li>its <a>lexical-to-value mapping</a> consists in parsing the <a>lexical form</a> as specified by [<a data-cite="N-TRIPLES#h3_sec-parsing-terms">N-TRIPLES, Section 8.1</a>].</li>
      </ul>
      <p>Any <a>RDF* interpretation</a> (see below) will be required to <a>recognize</a> this <a>datatype</a>, i.e., to correctly map <a>literals</a> of that datatype to the appropriate <a>IRI</a> or <a>literal</a>.</p>

      <p>For any <a>RDF* graph</a> |G|, we call the <dfn>asserted blank nodes</dfn> of |G| the set of <a>blank nodes</a> used in the <a>subject</a> or <a>object</a> position of some <a>asserted triple</a>. We call the <dfn>embedded blank nodes</dfn> of |G| the set of <a>blank nodes</a> used in the <a>subject</a> or <a>object</a> position of some <a>embedded triple</a>. We call the <dfn>mixed blank nodes</dfn> of |G| the set of <a>blank nodes</a> that are at the same time asserted and embedded.</p>
    </section>

    <section>
      <h2>Mapping RDF* abstract syntax to RDF</h2>

      <p>Given an <a>RDF* graph</a> |G|, the following steps transform it into an <a>RDF graph</a> that we call |unstar|(|G|).</p>

      <ol>
        <li>Define an injective mapping |Q| from the set of <a>mixed blank nodes</a> of |G| to a set of fresh (i.e., not occurring in |G|) <a>blank nodes</a>.</li>
        <li>Extend |Q| to other <a>RDF* terms</a> as follows:<ul>
          <li>for any <a>IRI</a> or <a>literal</a> |g|,  |Q|(|g|) is a <a>literal</a> of <a>datatype</a> <var>D*</var>, whose value through the <a>lexical-to-value mapping</a> is |g|,</li>
          <li>for any <a>blank node</a> |b| that is not a <a>mixed blank node</a>, |Q|(|b|) = |b|,</li>
          <li>for any <a>RDF* triple</a> |t|, |Q|(|t|) = |t|.</li>
        </ul></li>
        <li>For each <a>mixed blank node</a> |b| of |G|, add the following triple in |G|: (|Q|(|b|), <var>I*</var>, |b|).</li>
        <li>For each <a>embedded triple</a> (|s|, |p|, |o|) in <a>constituents</a>(|G|), replace all its occurrences in |G| with a fresh blank node |b|, and add the three following triples in |G|: (|b|, <var>S*</var>, |Q|(|s|)), (|b|, <var>P*</var>, |Q|(|p|)), and (|b|, <var>O*</var>, |Q|(|o|)).
        </li>
      </ol>
      <p>After these steps, |unstar|(|G|) is an <a>RDF graph</a>, as it contains no embedded triples. Note that if |G| was already an <a>RDF graph</a>, then |unstar|(|G|) = |G|.</p>

    </section>

    <section>
      <h2>RDF* Interpretation</h2>

      <p>Given a set |D| of <a>IRIs</a> denoting <a>datatypes</a>, an <dfn>RDF* interpretation</dfn> (<a>recognizing</a> |D|) is an <a>RDF interpretation</a> (<a>recognizing</a> |D|) satisfying the following additional constraints:</p>

      <ul>
        <li><var>D*</var> must be an element of the set |D| of <a>recognized</a> <a>datatypes</a>.</li>
        <li>The universe |IR| must contain all <a>RDF* terms</a>.</li>
        <li>|IEXT|(<var>S*</var>) = { ( (|s|, |p|, |o|), |s| ) for all <a>RDF* triple</a> (|s|, |p|, |o|) }</li>
        <li>|IEXT|(<var>P*</var>) = { ( (|s|, |p|, |o|), |p| ) for all <a>RDF* triple</a> (|s|, |p|, |o|) }</li>
        <li>|IEXT|(<var>O*</var>) = { ( (|s|, |p|, |o|), |o| ) for all <a>RDF* triple</a> (|s|, |p|, |o|) }</li>
        <li>|IEXT|(<var>I*</var>) = |IS| ∪ |IL| ∪ |IDT| (where |IDT| is the identity function on the set of all <a>RDF* triples</a>)</li>
      </ul>
    </section>

    <section>
      <h2>RDF* Entailment</h2>

      <p>Following [[[RDF11-MT]]], we extend the notions of satisfiability and entailment for <a>RDF* interpretations</a>. Given a set |D| of <a>IRIs</a> denoting <a>datatypes</a> and two <a>RDF* graphs</a> |G| and |H|:<p>
      <ul>
        <li>An <a>RDF* interpretation</a> |I| <dfn data-lt="satisfying|satisfies">satisfies</dfn> |G| if |I|(|unstar|(|G|)) = true. In the particular case of <a>RDF graphs</a>, this is equivalent to |I|(|G|) = true, consistent with the definitions in [[RDF11-MT]].</li>
        <li>|G| <dfn>RDF* entails (recognizing |D|)</dfn> |H| when every <a>RDF* interpretation</a> <a>recognizing</a> |D| which <a>satisfies</a> |G| also <a>satisfies</a> |H|.</li>
        <li>We simply say that |G| <dfn>RDF* entails</dfn> |H| when |D| = {`rdf:langString`, `xsd:string`, <var>D*</var>}.</li>
        <li>|G| is <dfn>RDF* unsatisfiable (recognizing |D|)</dfn> when it has no <a>satisfying</a> <a>RDF* interpretation</a> (<a>recognizing</a> |D|).</li>
      </ul>
    </section>

    <section class="informative">
      <h2>Remarks</h2>
      <p>Any <a>ground</a> <a>embedded triple</a> (|s|, |p|, |o|) is technically replaced by a blank node, acting as an existential variable, but it is pinpointed by <var>S*</var>, <var>P*</var> and <var>O*</var> to a single element of the universe, which is the triple (|s|, |p|, |o|) itself. As such, it behaves similarly to a literal (i.e., it denotes the same thing in every interpretation).</p>

      <p>A non-<a>ground</a> <a>embedded triple</a>, such as `&lt;&lt; :s :p _:x &gt;&gt;` is replaced by a blank node, acting as an existential variable, that can be mapped to any triple with subject `http://example.org/s` and predicate `http://example.org/p`. This is consistent with the SPARQL* evaluation semantics.</p>

      <p>The point above means that we have no way to precisely mention a specific triple containing a <a>blank node</a>. This is not considered as a problem, however, since such limitations already exist in RDF: there is no way in RDF concrete syntaxes to mention a specific <a>blank node</a> |b| as defined in the abstract syntax.</p>
        
      <p>The point above means that the following piece of Turtle* `&lt;file.ttl&gt; :contains &lt;&lt; :s :p _:x &gt;&gt;.` does only say "file.ttl contains a triple with subject `http://example.org/s` and predicate `http://example.org/p`", it does not add "and a <a>blank node</a> as its object" (because `_:x` here can could be mapped to any <a>RDF* term</a>). There is currently no way to convey the second part of the sentence, but one could imagine an additional vocabulary to do that, if deemed useful.</p>

      <p>Another subtlety about <a>blank nodes</a> is that <a>mixed blank nodes</a> are mapped to a <em>pair</em> of distinct but related <a>blank nodes</a>. Consider the following Turtle* example.</p>

      <pre data-transform="updateExample"
           data-content-type="application/x-sparql-star-query"
           class="nohighlight example"
      >
          <!--
              :alice :father _:x.
              << _:x :name "Bob" >> :accordingTo :alice.
          -->
      </pre>

      <p>The first `_:x` is interpreted as a <a>blank node</a> (let's call it |x|) acting as an existential variable that can be mapped to virtually anything. The second `_:x` is internally changed to |Q|(|x|), another <a>blank node</a>, which can be mapped only to <a>RDF* terms</a>, as it must be in the range of <var>S*</var>. Both <a>blank nodes</a> |x| and |Q|(|x|) are constrained by the <var>I*</var> property, which ensures that, modulo one level of indirection, they always represent the same thing.</p>

      <p>Finally, it is worth noticing that the <a>IRIs</a> <var>D*</var>, <var>S*</var>, <var>P*</var>, <var>O*</var> and <var>I*</var> are not explicitly specified (beyond their existence) by this document. With this omission, this specification provides no standard way to convey an <a>RDF* graph</a> using older RDF concrete syntaxes &mdash; only the RDF*-specific extensions of those concrete syntaxes can be used for that. Otherwise, it would have been possible to describe incomplete or ill-formed <a>RDF* triples</a> (a problem that exists with <a data-cite="RDF-SCHEMA#ch_collectionvocab">RDF collections</a> for example), thus forcing implementations to deal with pathological cases, and preventing useful optimisations.</p>

      <p class="issue">
        Do we want to keep it that way, or do we want to specify these IRIs (or some of them) anyway?
      </p>
    </section>

  </section>

  <section class="appendix">
    <h2>Historical remarks</h2>

    <section class="appendix">
      <h2>SA-mode and PG-mode</h2>

      <p>A lot of discussions on the <a href="https://lists.w3.org/Archives/Public/public-rdf-star/">RDF* mailing list</a> and <a href="https://github.com/w3c/rdf-star">GitHub repository</a> refer to SA-mode and PG-mode. Those abbreviations stand for "Separate Assertion mode" and "Property Graph mode". They originate in the fact that different versions of RDF* have been published over the years, with different designs. In PG-mode, any <a>embedded triple</a> was also considered <a>asserted</a>. SA-mode, on the other hand, allowed the use of <a>embedded triples</a> without those triples being automatically <a>asserted</a>, requiring that they be <a>asserted</a> separately when that was intended. SA-mode was more flexible, but induced redundancy in the use-cases that PG-mode was designed to address.</p>

      <p>The notion of <a href="#grammar-production-annotation">annotations</a> in the <a href="#turtle-star">Turtle*</a> syntax was introduced to remove the need for different modes. Rather than interpret the same syntax differently in each mode, which would have caused interoperability problems and required a switch for those modes, it was decided to provide a different syntax for each use case.</p>

      <ul>
        <li>The <code>&lt;&lt; ... &gt;&gt;</code> syntax represents a triple that is <a>embedded</a> without being <a>asserted</a>, satisfying the need formerly filled by SA-mode.</li>
        <li>The <code>:a :b :c {| :p :o ... |}</code> annotation syntax creates triples where the subject is an <a>embedded</a> version of the triple <a>asserted</a> just before the annotation (here, <code>:a :b :c</code>), without the need to repeat it, satisfying the need formerly filled by PG-mode.</li>
      </ul>
    </section>

  </section>

  <section class="appendix" id="issue-summary">
    <!-- A list of issues will magically appear here -->
  </section>
</body>
</html>
